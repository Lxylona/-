/**
 *
 * @困难
 *
 * 给定一个字符串 (s) 和一个字符模式 (p)。实现支持 '.' 和 '*' 的正则表达式匹配。
 * '.' 匹配任意单个字符。
 * '*' 匹配零个或多个前面的元素。
 * 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。
 * 说明：
 * s 可能为空，且只包含从 a-z 的小写字母。
 * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
 */

/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 * 时间复杂度 O(nm), 空间复杂度 O(m)
 */
var isMatch = function(s, p) {
  // cur[0][0] = true; 因为 ''和'' 能够匹配
  let cur = [true];
  let pre = [];
  for (let i = 0; i <= s.length; i++) {
    for (let j = 1; j <= p.length; j++) {
      // 循环，那么有两种情况：
      // 1. 循环 0 次，那么看循环之前的是否匹配
      // 2. 循环了至少一次，那么看循环的字符是否相符
      if (p[j - 1] === '*') {
        cur[j] = cur[j - 2] || (i && pre[j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));
      } else {
        // 普通的字符，那么条件是之前匹配上了，并且当前字符是匹配的
        cur[j] = i && pre[j - 1] && (s[i - 1] === p[j - 1] || p[j - 1] === '.');
      }
    }
    pre = cur;
    cur = [];
  }
  return !!pre[p.length];
};

let result = isMatch('aa', 'a');
// console.log(result);
/**
 * @总结
 * 1. 这种问题是比较典型的动态规划问题，s 的 0 ～ i 子串能否匹配上取决于该子串 i 字符能够匹配上以及 0 ～ i - 1 能否匹配上。
 * 2. 刚开始把问题想复杂了，想用有限状态机（语法分析）来实现，其实没有必要，因为这里场景太简单了，用有限状态机根本就是把简单的问题复杂化。
 */
